/* tslint:disable */
/* eslint-disable */
/* Code generated by ng-openapi-gen DO NOT EDIT. */

import { HttpClient, HttpContext } from '@angular/common/http';
import { Injectable } from '@angular/core';
import { Observable } from 'rxjs';
import { map } from 'rxjs/operators';

import { BaseService } from '../base-service';
import { ApiConfiguration } from '../api-configuration';
import { StrictHttpResponse } from '../strict-http-response';

import { archiveNotification } from '../fn/notification-controller/archive-notification';
import { ArchiveNotification$Params } from '../fn/notification-controller/archive-notification';
import { createBulkNotifications } from '../fn/notification-controller/create-bulk-notifications';
import { CreateBulkNotifications$Params } from '../fn/notification-controller/create-bulk-notifications';
import { deactivateFcmToken } from '../fn/notification-controller/deactivate-fcm-token';
import { DeactivateFcmToken$Params } from '../fn/notification-controller/deactivate-fcm-token';
import { getMyNotifications } from '../fn/notification-controller/get-my-notifications';
import { GetMyNotifications$Params } from '../fn/notification-controller/get-my-notifications';
import { getMyUnreadCount } from '../fn/notification-controller/get-my-unread-count';
import { GetMyUnreadCount$Params } from '../fn/notification-controller/get-my-unread-count';
import { markAllAsRead } from '../fn/notification-controller/mark-all-as-read';
import { MarkAllAsRead$Params } from '../fn/notification-controller/mark-all-as-read';
import { markAsRead } from '../fn/notification-controller/mark-as-read';
import { MarkAsRead$Params } from '../fn/notification-controller/mark-as-read';
import { registerFcmToken } from '../fn/notification-controller/register-fcm-token';
import { RegisterFcmToken$Params } from '../fn/notification-controller/register-fcm-token';
import { SuccessResponseNotificationResponseDto } from '../models/success-response-notification-response-dto';
import { SuccessResponseNumber } from '../models/success-response-number';
import { SuccessResponseString } from '../models/success-response-string';
import { SuccessResponseVoid } from '../models/success-response-void';

@Injectable({ providedIn: 'root' })
export class NotificationControllerService extends BaseService {
  constructor(config: ApiConfiguration, http: HttpClient) {
    super(config, http);
  }

  /** Path part for operation `createBulkNotifications()` */
  static readonly CreateBulkNotificationsPath = '/api/notifications/bulk';

  /**
   * Create bulk notifications.
   *
   *
   *
   * This method provides access to the full `HttpResponse`, allowing access to response headers.
   * To access only the response body, use `createBulkNotifications()` instead.
   *
   * This method sends `application/json` and handles request body of type `application/json`.
   */
  createBulkNotifications$Response(params: CreateBulkNotifications$Params, context?: HttpContext): Observable<StrictHttpResponse<SuccessResponseNotificationResponseDto>> {
    return createBulkNotifications(this.http, this.rootUrl, params, context);
  }

  /**
   * Create bulk notifications.
   *
   *
   *
   * This method provides access only to the response body.
   * To access the full response (for headers, for example), `createBulkNotifications$Response()` instead.
   *
   * This method sends `application/json` and handles request body of type `application/json`.
   */
  createBulkNotifications(params: CreateBulkNotifications$Params, context?: HttpContext): Observable<SuccessResponseNotificationResponseDto> {
    return this.createBulkNotifications$Response(params, context).pipe(
      map((r: StrictHttpResponse<SuccessResponseNotificationResponseDto>): SuccessResponseNotificationResponseDto => r.body)
    );
  }

  /** Path part for operation `getMyNotifications()` */
  static readonly GetMyNotificationsPath = '/api/notifications/me';

  /**
   * Get my notifications.
   *
   *
   *
   * This method provides access to the full `HttpResponse`, allowing access to response headers.
   * To access only the response body, use `getMyNotifications()` instead.
   *
   * This method doesn't expect any request body.
   */
  getMyNotifications$Response(params?: GetMyNotifications$Params, context?: HttpContext): Observable<StrictHttpResponse<SuccessResponseNotificationResponseDto>> {
    return getMyNotifications(this.http, this.rootUrl, params, context);
  }

  /**
   * Get my notifications.
   *
   *
   *
   * This method provides access only to the response body.
   * To access the full response (for headers, for example), `getMyNotifications$Response()` instead.
   *
   * This method doesn't expect any request body.
   */
  getMyNotifications(params?: GetMyNotifications$Params, context?: HttpContext): Observable<SuccessResponseNotificationResponseDto> {
    return this.getMyNotifications$Response(params, context).pipe(
      map((r: StrictHttpResponse<SuccessResponseNotificationResponseDto>): SuccessResponseNotificationResponseDto => r.body)
    );
  }

  /** Path part for operation `getMyUnreadCount()` */
  static readonly GetMyUnreadCountPath = '/api/notifications/me/unread/count';

  /**
   * Get my unread notification count.
   *
   *
   *
   * This method provides access to the full `HttpResponse`, allowing access to response headers.
   * To access only the response body, use `getMyUnreadCount()` instead.
   *
   * This method doesn't expect any request body.
   */
  getMyUnreadCount$Response(params?: GetMyUnreadCount$Params, context?: HttpContext): Observable<StrictHttpResponse<SuccessResponseNumber>> {
    return getMyUnreadCount(this.http, this.rootUrl, params, context);
  }

  /**
   * Get my unread notification count.
   *
   *
   *
   * This method provides access only to the response body.
   * To access the full response (for headers, for example), `getMyUnreadCount$Response()` instead.
   *
   * This method doesn't expect any request body.
   */
  getMyUnreadCount(params?: GetMyUnreadCount$Params, context?: HttpContext): Observable<SuccessResponseNumber> {
    return this.getMyUnreadCount$Response(params, context).pipe(
      map((r: StrictHttpResponse<SuccessResponseNumber>): SuccessResponseNumber => r.body)
    );
  }

  /** Path part for operation `markAsRead()` */
  static readonly MarkAsReadPath = '/api/notifications/me/update/{id}/read';

  /**
   * Mark notification as read.
   *
   *
   *
   * This method provides access to the full `HttpResponse`, allowing access to response headers.
   * To access only the response body, use `markAsRead()` instead.
   *
   * This method doesn't expect any request body.
   */
  markAsRead$Response(params: MarkAsRead$Params, context?: HttpContext): Observable<StrictHttpResponse<SuccessResponseVoid>> {
    return markAsRead(this.http, this.rootUrl, params, context);
  }

  /**
   * Mark notification as read.
   *
   *
   *
   * This method provides access only to the response body.
   * To access the full response (for headers, for example), `markAsRead$Response()` instead.
   *
   * This method doesn't expect any request body.
   */
  markAsRead(params: MarkAsRead$Params, context?: HttpContext): Observable<SuccessResponseVoid> {
    return this.markAsRead$Response(params, context).pipe(
      map((r: StrictHttpResponse<SuccessResponseVoid>): SuccessResponseVoid => r.body)
    );
  }

  /** Path part for operation `markAllAsRead()` */
  static readonly MarkAllAsReadPath = '/api/notifications/me/update/read-all';

  /**
   * Mark all my notifications as read.
   *
   *
   *
   * This method provides access to the full `HttpResponse`, allowing access to response headers.
   * To access only the response body, use `markAllAsRead()` instead.
   *
   * This method doesn't expect any request body.
   */
  markAllAsRead$Response(params?: MarkAllAsRead$Params, context?: HttpContext): Observable<StrictHttpResponse<SuccessResponseVoid>> {
    return markAllAsRead(this.http, this.rootUrl, params, context);
  }

  /**
   * Mark all my notifications as read.
   *
   *
   *
   * This method provides access only to the response body.
   * To access the full response (for headers, for example), `markAllAsRead$Response()` instead.
   *
   * This method doesn't expect any request body.
   */
  markAllAsRead(params?: MarkAllAsRead$Params, context?: HttpContext): Observable<SuccessResponseVoid> {
    return this.markAllAsRead$Response(params, context).pipe(
      map((r: StrictHttpResponse<SuccessResponseVoid>): SuccessResponseVoid => r.body)
    );
  }

  /** Path part for operation `archiveNotification()` */
  static readonly ArchiveNotificationPath = '/api/notifications/me/update/{id}/archive';

  /**
   * Archive notification.
   *
   *
   *
   * This method provides access to the full `HttpResponse`, allowing access to response headers.
   * To access only the response body, use `archiveNotification()` instead.
   *
   * This method doesn't expect any request body.
   */
  archiveNotification$Response(params: ArchiveNotification$Params, context?: HttpContext): Observable<StrictHttpResponse<SuccessResponseVoid>> {
    return archiveNotification(this.http, this.rootUrl, params, context);
  }

  /**
   * Archive notification.
   *
   *
   *
   * This method provides access only to the response body.
   * To access the full response (for headers, for example), `archiveNotification$Response()` instead.
   *
   * This method doesn't expect any request body.
   */
  archiveNotification(params: ArchiveNotification$Params, context?: HttpContext): Observable<SuccessResponseVoid> {
    return this.archiveNotification$Response(params, context).pipe(
      map((r: StrictHttpResponse<SuccessResponseVoid>): SuccessResponseVoid => r.body)
    );
  }

  /** Path part for operation `registerFcmToken()` */
  static readonly RegisterFcmTokenPath = '/api/notifications/fcm-token';

  /**
   * Register FCM token for push notifications.
   *
   *
   *
   * This method provides access to the full `HttpResponse`, allowing access to response headers.
   * To access only the response body, use `registerFcmToken()` instead.
   *
   * This method sends `application/json` and handles request body of type `application/json`.
   */
  registerFcmToken$Response(params: RegisterFcmToken$Params, context?: HttpContext): Observable<StrictHttpResponse<SuccessResponseString>> {
    return registerFcmToken(this.http, this.rootUrl, params, context);
  }

  /**
   * Register FCM token for push notifications.
   *
   *
   *
   * This method provides access only to the response body.
   * To access the full response (for headers, for example), `registerFcmToken$Response()` instead.
   *
   * This method sends `application/json` and handles request body of type `application/json`.
   */
  registerFcmToken(params: RegisterFcmToken$Params, context?: HttpContext): Observable<SuccessResponseString> {
    return this.registerFcmToken$Response(params, context).pipe(
      map((r: StrictHttpResponse<SuccessResponseString>): SuccessResponseString => r.body)
    );
  }

  /** Path part for operation `deactivateFcmToken()` */
  static readonly DeactivateFcmTokenPath = '/api/notifications/fcm-token/{token}';

  /**
   * Deactivate FCM token.
   *
   *
   *
   * This method provides access to the full `HttpResponse`, allowing access to response headers.
   * To access only the response body, use `deactivateFcmToken()` instead.
   *
   * This method doesn't expect any request body.
   */
  deactivateFcmToken$Response(params: DeactivateFcmToken$Params, context?: HttpContext): Observable<StrictHttpResponse<SuccessResponseVoid>> {
    return deactivateFcmToken(this.http, this.rootUrl, params, context);
  }

  /**
   * Deactivate FCM token.
   *
   *
   *
   * This method provides access only to the response body.
   * To access the full response (for headers, for example), `deactivateFcmToken$Response()` instead.
   *
   * This method doesn't expect any request body.
   */
  deactivateFcmToken(params: DeactivateFcmToken$Params, context?: HttpContext): Observable<SuccessResponseVoid> {
    return this.deactivateFcmToken$Response(params, context).pipe(
      map((r: StrictHttpResponse<SuccessResponseVoid>): SuccessResponseVoid => r.body)
    );
  }

}
